<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splat : Affinity Diagramming Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --her-coral: #D95030;
            --her-coral-light: #E8705A;
            --her-coral-dark: #C44528;
            --her-beige: #F5EDE0;
            --her-cream: #FBF8F3;
            --her-slate: #6B7B8C;
            --her-slate-light: #8A97A5;
            --her-pink: #E8A49C;
            --her-pink-light: #F5D4CF;
            --her-dark: #3D3D3D;
            --her-teal: #4A6B6B;
            --her-sand: #C9B896;
            --her-warm-brown: #8B6B4D;
            --her-text: #1A1A1A;
            --her-text-muted: #4A4A4A;
            --her-text-on-dark: #FFFFFF;
            --her-text-on-note: #2D2D2D;
            --shadow-soft: 0 4px 20px rgba(61, 61, 61, 0.08);
            --shadow-medium: 0 8px 30px rgba(61, 61, 61, 0.12);
            --shadow-hover: 0 12px 40px rgba(217, 80, 48, 0.15);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--her-beige);
            overflow: hidden;
            color: var(--her-text);
        }

        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--her-cream);
            padding: 14px 24px;
            border-bottom: 1px solid rgba(201, 184, 150, 0.3);
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: var(--shadow-soft);
            /* Allow toolbar to wrap on smaller screens */
            flex-wrap: wrap;
        }

        .toolbar-logo {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            font-size: 20px;
            color: var(--her-coral);
            letter-spacing: -0.5px;
            margin-right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-logo::before {
            content: '';
            width: 24px;
            height: 24px;
            background: var(--her-coral);
            border-radius: 50%;
            display: inline-block;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--her-sand);
            opacity: 0.5;
            margin: 0 8px;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            font-family: 'DM Sans', sans-serif;
            transition: var(--transition);
            letter-spacing: 0.2px;
        }

        .btn-primary {
            background: var(--her-coral);
            color: var(--her-text-on-dark);
            box-shadow: 0 2px 8px rgba(217, 80, 48, 0.25);
        }

        .btn-primary:hover {
            background: var(--her-coral-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(217, 80, 48, 0.35);
        }

        .btn-secondary {
            background: transparent;
            color: var(--her-text);
            border: 1.5px solid var(--her-sand);
        }

        .btn-secondary:hover {
            background: var(--her-beige);
            border-color: var(--her-slate-light);
        }

        .btn-toggle {
            background: var(--her-teal);
            color: var(--her-text-on-dark);
            border: none;
        }

        .btn-toggle:hover {
            background: #3D5C5C;
        }

        .btn-toggle.active {
            background: var(--her-coral);
        }

        .btn-toggle.active:hover {
            background: var(--her-coral-dark);
        }

        .file-input {
            display: none;
        }

        .canvas {
            position: absolute;
            top: 64px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            background: var(--her-beige);
            background-image:
                /* radial-gradient(circle, var(--her-coral) 1px, transparent 1px); */
                radial-gradient(circle, rgba(217, 80, 48, 0.4) 1px, transparent 1px);
            background-size: 24px 24px;
            cursor: grab;
        }

        .canvas:active {
            cursor: grabbing;
        }

        .canvas-inner {
            position: relative;
            min-width: 4000px;
            min-height: 4000px;
            transform-origin: 0 0;
            transition: transform 0.2s ease;
        }

        .note {
            position: absolute;
            width: 200px;
            min-height: 110px;
            background: #FFF9E6;
            border: none;
            border-radius: 12px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.5;
            cursor: move;
            user-select: none;
            box-shadow: var(--shadow-soft);
            transition: var(--transition);
            font-family: 'DM Sans', sans-serif;
            word-wrap: break-word;
            resize: both;
            overflow: visible;
        }

        .note:hover {
            transform: translateY(-4px) rotate(0.5deg);
            box-shadow: var(--shadow-hover);
        }

        .note.dragging {
            z-index: 1000;
            transform: rotate(2deg) scale(1.03);
            box-shadow: var(--shadow-medium);
        }

        /* ============================================
           "Her" inspired note colors
        ============================================ */
        /* Coral/Red-Orange from Her */
        .note.color-coral {
            background: linear-gradient(145deg, #F2B5A0 0%, #E8A08A 100%);
            color: var(--her-text-on-note);
        }
        /* Warm Beige/Sand from Her */
        .note.color-sand {
            background: linear-gradient(145deg, #E8DCCA 0%, #D4C4A8 100%);
            color: var(--her-text-on-note);
        }
        /* Soft Pink from Her */
        .note.color-pink {
            background: linear-gradient(145deg, #F5D4CF 0%, #E8B8B0 100%);
            color: var(--her-text-on-note);
        }
        /* Muted Slate Blue from Her */
        .note.color-slate {
            background: linear-gradient(145deg, #B8C4D0 0%, #9CAEBB 100%);
            color: var(--her-text-on-note);
        }
        /* Warm Brown/Tan from Her */
        .note.color-tan {
            background: linear-gradient(145deg, #D4C0A8 0%, #C4A888 100%);
            color: var(--her-text-on-note);
        }
        /* Dark Teal from Her */
        .note.color-teal {
            background: linear-gradient(145deg, #8AA8A8 0%, #6B8B8B 100%);
            color: var(--her-text-on-note);
        }

        .note.selected {
            border: 2px solid var(--her-coral);
            box-shadow: 0 0 0 4px rgba(217, 80, 48, 0.15);
        }

        .pin-indicator {
            position: absolute;
            top: -10px;
            left: -8px;
            width: 20px;
            height: 20px;
            display: none;
        }

        .pin-indicator::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 10px;
            background: var(--her-coral);
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .note.pinned .pin-indicator {
            display: block;
        }

        .note.pinned {
            border-left: 3px solid var(--her-coral);
        }

        .selection-rectangle {
            position: absolute;
            border: 2px dashed var(--her-coral);
            background: rgba(217, 80, 48, 0.08);
            pointer-events: none;
            z-index: 999;
            display: none;
            border-radius: 8px;
        }

        .note-menu {
            position: absolute;
            top: -10px;
            right: -10px;
            display: none;
            flex-direction: column;
            gap: 4px;
            z-index: 1001;
        }

        .note:hover .note-menu {
            display: flex;
        }

        .note-menu-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-soft);
            transition: var(--transition);
            background: var(--her-cream);
        }

        .note-menu-btn:hover {
            transform: scale(1.1);
        }

        .pin-btn {
            color: var(--her-coral);
        }

        .color-btn {
            color: var(--her-slate);
        }

        .delete-btn {
            background: var(--her-coral);
            color: var(--her-text-on-dark);
        }
        .delete-btn:hover {
            background: var(--her-coral-dark);
        }

        .duplicate-btn {
            background: var(--her-teal);
            color: var(--her-text-on-dark);
        }
        .duplicate-btn:hover {
            background: #3D5C5C;
        }

        .status {
            margin-left: auto;
            font-size: 12px;
            color: var(--her-text-muted);
            padding: 6px 14px;
            background: var(--her-beige);
            border-radius: 20px;
        }

        .drop-zone {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(217, 80, 48, 0.1);
            border: 3px dashed var(--her-coral);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            font-size: 22px;
            color: var(--her-coral);
            font-weight: 500;
            font-family: 'Space Grotesk', sans-serif;
        }

        .drop-zone.active {
            display: flex;
        }

        .color-picker {
            position: absolute;
            background: var(--her-cream);
            border: none;
            border-radius: 16px;
            padding: 12px;
            box-shadow: var(--shadow-medium);
            display: none;
            gap: 8px;
            z-index: 1001;
        }

        .color-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: var(--transition);
        }

        .color-option:hover {
            border-color: var(--her-dark);
            transform: scale(1.15);
        }

        .search-container {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 8px;
            padding-left: 16px;
            border-left: 1px solid var(--her-sand);
        }

        .search-input {
            padding: 10px 18px;
            border: 1.5px solid var(--her-sand);
            border-radius: 24px;
            font-size: 13px;
            width: 200px;
            outline: none;
            transition: var(--transition);
            font-family: 'DM Sans', sans-serif;
            background: var(--her-cream);
            color: var(--her-text);
        }

        .search-input::placeholder {
            color: var(--her-slate-light);
        }

        .search-input:focus {
            border-color: var(--her-coral);
            box-shadow: 0 0 0 4px rgba(217, 80, 48, 0.1);
        }

        .search-input:disabled {
            background: var(--her-beige);
            color: var(--her-slate);
        }

        .search-btn {
            padding: 10px 20px;
            background: var(--her-coral);
            color: var(--her-cream);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 90px;
        }

        .search-btn:hover {
            background: var(--her-coral-dark);
            transform: translateY(-1px);
        }

        .search-btn.loading {
            pointer-events: none;
            opacity: 0.85;
        }

        .search-btn .search-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--her-cream);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .search-btn:disabled {
            background: var(--her-sand);
            cursor: not-allowed;
        }

        .note.search-highlight {
            border: 3px solid var(--her-coral) !important;
            box-shadow: 0 0 0 4px rgba(217, 80, 48, 0.2), var(--shadow-medium) !important;
        }

        .note.ai-highlight {
            border: 3px solid var(--her-teal) !important;
            box-shadow: 0 0 0 4px rgba(74, 107, 107, 0.2), var(--shadow-medium) !important;
        }

        .note.warning-highlight {
            border: 3px solid #C44528 !important;
            box-shadow: 0 0 0 4px rgba(196, 69, 40, 0.25), var(--shadow-medium) !important;
            animation: pulse-warning 1.2s ease-in-out infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .chat-pane {
            position: fixed;
            right: -440px;
            top: 64px;
            bottom: 0;
            width: 420px;
            max-width: 100vw;
            background: var(--her-cream);
            border-radius: 32px 0 0 32px;
            border-left: 1px solid rgba(201, 184, 150, 0.3);
            display: flex;
            flex-direction: column;
            z-index: 1001;
            box-shadow: -8px 0 30px rgba(61, 61, 61, 0.1);
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 16px;
            margin-bottom: 16px;
        }

        .chat-pane.open {
            right: 0;
        }

        .chat-header {
            background: var(--her-coral);
            color: var(--her-text-on-dark);
            padding: 18px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 32px 0 0 0;
        }

        .chat-title {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 500;
            font-size: 16px;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .chat-header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .chat-close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            background: var(--her-beige);
        }

        .chat-welcome {
            background: var(--her-cream);
            padding: 20px;
            border-radius: 16px;
            font-size: 14px;
            color: var(--her-text-muted);
            box-shadow: var(--shadow-soft);
            line-height: 1.6;
        }

        .chat-welcome strong {
            color: var(--her-text);
        }

        .chat-welcome ul {
            margin: 12px 0 0 0;
            padding-left: 20px;
        }

        .chat-welcome li {
            margin: 8px 0;
            color: var(--her-coral);
            font-style: italic;
        }

        .chat-message {
            padding: 14px 18px;
            border-radius: 20px;
            max-width: 85%;
            font-size: 14px;
            line-height: 1.55;
            word-wrap: break-word;
        }

        .chat-message-user {
            background: var(--her-coral);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 6px;
            box-shadow: 0 2px 12px rgba(217, 80, 48, 0.25);
        }

        .chat-message-assistant {
            background: var(--her-cream);
            color: var(--her-text);
            align-self: flex-start;
            border-bottom-left-radius: 6px;
            box-shadow: var(--shadow-soft);
        }

        .chat-message-error {
            background: var(--her-pink-light);
            color: #8B3A32;
            align-self: center;
            font-size: 13px;
        }

        .chat-message-typing {
            background: var(--her-cream);
            align-self: flex-start;
            padding: 14px 22px;
            box-shadow: var(--shadow-soft);
        }

        .typing-dots span {
            animation: typing 1.4s infinite;
            font-size: 20px;
            color: var(--her-coral);
        }

        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { opacity: 0.3; }
            30% { opacity: 1; }
        }

        .loading-dots {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .loading-dots span {
            width: 8px;
            height: 8px;
            background: var(--her-coral);
            border-radius: 50%;
            animation: bounce-dot 1.4s ease-in-out infinite;
        }

        .loading-dots span:nth-child(2) { animation-delay: 0.16s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.32s; }

        @keyframes bounce-dot {
            0%, 80%, 100% {
                transform: scale(0.6);
                opacity: 0.4;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .processing-wave {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            height: 20px;
        }

        .processing-wave span {
            width: 3px;
            height: 100%;
            background: var(--her-coral);
            border-radius: 2px;
            animation: wave 1.2s ease-in-out infinite;
        }

        .processing-wave span:nth-child(1) { animation-delay: 0s; }
        .processing-wave span:nth-child(2) { animation-delay: 0.1s; }
        .processing-wave span:nth-child(3) { animation-delay: 0.2s; }
        .processing-wave span:nth-child(4) { animation-delay: 0.3s; }
        .processing-wave span:nth-child(5) { animation-delay: 0.4s; }

        @keyframes wave {
            0%, 100% {
                height: 4px;
                opacity: 0.4;
            }
            50% {
                height: 20px;
                opacity: 1;
            }
        }

        .transcribing-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .transcribing-indicator::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--her-coral);
            animation: pulse-transcribe 1.5s ease-out infinite;
        }

        @keyframes pulse-transcribe {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .spinner-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .chat-send-btn.loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .chat-send-btn.loading svg {
            animation: spin 1s linear infinite;
        }

        .voice-input-btn.transcribing {
            background: var(--her-teal);
            color: white;
        }

        .voice-input-btn.transcribing svg {
            animation: spin 1s linear infinite;
        }

        .chat-input-area {
            padding: 16px;
            background: var(--her-cream);
            border-top: 1px solid rgba(201, 184, 150, 0.3);
            display: flex;
            gap: 10px;
            align-items: flex-end;
            border-radius: 0 0 0 32px;
        }

        .chat-input-area textarea {
            flex: 1;
            border: 1.5px solid var(--her-sand);
            border-radius: 24px;
            padding: 12px 18px;
            font-size: 14px;
            resize: none;
            outline: none;
            font-family: 'DM Sans', sans-serif;
            background: var(--her-beige);
            color: var(--her-text);
            transition: var(--transition);
        }

        .chat-input-area textarea::placeholder {
            color: var(--her-slate-light);
        }

        .chat-input-area textarea:focus {
            border-color: var(--her-coral);
            box-shadow: 0 0 0 4px rgba(217, 80, 48, 0.1);
        }

        .chat-send-btn {
            background: var(--her-coral);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            font-size: 18px;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 12px rgba(217, 80, 48, 0.3);
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(217, 80, 48, 0.4);
        }

        .chat-send-btn:active {
            transform: scale(0.98);
        }

        .ask-button {
            position: fixed;
            bottom: 28px;
            right: 28px;
            background: var(--her-coral);
            color: white;
            border: none;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Space Grotesk', sans-serif;
            cursor: pointer;
            box-shadow: 0 6px 24px rgba(217, 80, 48, 0.4);
            z-index: 1000;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ask-button::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
        }

        .ask-button::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse-ask 2s ease-in-out infinite;
        }

        @keyframes pulse-ask {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        .ask-button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 10px 32px rgba(217, 80, 48, 0.5);
        }

        .voice-input-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: var(--her-beige);
            font-size: 16px;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--her-slate);
        }

        .voice-input-btn:hover {
            background: var(--her-sand);
            color: var(--her-text);
        }

        .voice-input-btn.recording {
            background: var(--her-coral);
            color: white;
            animation: pulse-recording 1.5s infinite;
        }

        .voice-input-btn.processing,
        .voice-input-btn.transcribing {
            background: var(--her-teal);
            color: white;
            animation: spin 1s linear infinite;
        }

        @keyframes pulse-recording {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(217, 80, 48, 0.7);
            }
            50% {
                box-shadow: 0 0 0 12px rgba(217, 80, 48, 0);
            }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #settingsPanel {
            background: var(--her-cream);
            border-bottom: 1px solid var(--her-sand);
            font-size: 13px;
        }

        #settingsPanel label {
            color: var(--her-text);
            display: block;
            margin-bottom: 12px;
        }

        #settingsPanel select,
        #settingsPanel input {
            font-family: 'DM Sans', sans-serif;
            padding: 10px 14px;
            border: 1.5px solid var(--her-sand);
            border-radius: 12px;
            background: var(--her-beige);
            color: var(--her-text);
            margin-top: 6px;
            outline: none;
            transition: var(--transition);
        }

        #settingsPanel select:focus,
        #settingsPanel input:focus {
            border-color: var(--her-coral);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--her-beige);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--her-sand);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--her-slate-light);
        }

        /* Small phones */
        @media (max-width: 480px) {
            .toolbar {
                padding: 10px 12px;
                gap: 6px;
            }

            .toolbar-logo {
                font-size: 16px;
                margin-right: 8px;
            }

            .toolbar-logo::before {
                width: 20px;
                height: 20px;
            }

            .toolbar-divider {
                display: none;
            }

            .btn {
                padding: 8px 12px;
                font-size: 11px;
            }

            .btn-secondary:not(:first-of-type) {
                display: none;
            }

            .status {
                display: none;
            }

            .chat-pane {
                width: 100vw;
                right: -100vw;
                top: 56px;
            }

            .chat-header h3 {
                font-size: 14px;
            }

            .note {
                min-width: 140px;
                min-height: 100px;
                font-size: 12px;
                padding: 12px;
            }

            .ask-button {
                width: 50px;
                height: 50px;
                bottom: 16px;
                right: 16px;
            }

            .ask-button::before, .ask-button::after {
                width: 18px;
                height: 18px;
            }
            .ask-button::after {
                width: 7px;
                height: 7px;
            }


            .group-label {
                font-size: 12px;
                padding: 6px 12px;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) {
            .toolbar {
                padding: 12px 16px;
                gap: 8px;
            }

            .toolbar-logo {
                font-size: 18px;
            }

            .btn {
                padding: 9px 14px;
                font-size: 12px;
            }

            .status {
                font-size: 11px;
                padding: 5px 10px;
            }

            .chat-pane {
                width: 360px;
                right: -360px;
            }

            .note {
                min-width: 150px;
                min-height: 110px;
                font-size: 13px;
            }

            .ask-button {
                width: 54px;
                height: 54px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .toolbar {
                padding: 12px 20px;
            }

            .chat-pane {
                width: 380px;
                right: -380px;
            }

            .note {
                min-width: 160px;
                min-height: 120px;
            }
        }

        @media (min-width: 1025px) and (max-width: 1440px) {
            .chat-pane {
                width: 400px;
                right: -400px;
            }
        }

        /* Extra large screens */
        @media (min-width: 1441px) {
            .toolbar {
                padding: 16px 32px;
            }

            .chat-pane {
                width: 480px;
                right: -480px;
            }

            .note {
                min-width: 200px;
                min-height: 150px;
                font-size: 15px;
            }

            .ask-button {
                width: 68px;
                height: 68px;
            }

            .ask-button::before, .ask-button::after {
                width: 24px;
                height: 24px;
            }
            .ask-button::after {
                width: 10px;
                height: 10px;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 44px;
                min-width: 44px;
            }

            .note-menu-btn {
                width: 32px;
                height: 32px;
            }

            .color-option {
                width: 36px;
                height: 36px;
            }

            .chat-input-area textarea {
                font-size: 16px;
            }

            .search-input {
                font-size: 16px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .toolbar {
                padding: 8px 16px;
            }

            .chat-pane {
                top: 50px;
            }

            .ask-button {
                bottom: 12px;
                right: 12px;
                width: 48px;
                height: 48px;
            }
        }

        @media print {
            .toolbar,
            .chat-pane,
            .ask-button,
            .color-picker {
                display: none !important;
            }

            .canvas {
                position: static;
                overflow: visible;
            }

            .note {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid var(--her-sand);
            }
        }

    </style>
</head>
<body>
    <div class="toolbar">
        <div class="toolbar-logo">splat</div>
        <div class="toolbar-divider"></div>
        <input type="file" id="fileInput" class="file-input" accept=".txt">
        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
            Load File
        </button>
        <button class="btn btn-primary" onclick="addNewNote()">
            New Note
        </button>
        <button class="btn btn-toggle" id="selectNotesBtn" onclick="toggleSelectMode()">
            Select
        </button>
        <div class="toolbar-divider"></div>
        <button class="btn btn-secondary" onclick="saveBoard()">Save Board</button>
        <button class="btn btn-secondary" onclick="loadBoard()">Load Board</button>
        <button class="btn btn-secondary" onclick="clearBoard()">Clear</button>
        <div class="toolbar-divider"></div>
        <button class="btn btn-secondary" onclick="zoomOut()">âˆ’</button>
        <button class="btn btn-secondary" onclick="resetZoom()">100%</button>
        <button class="btn btn-secondary" onclick="zoomIn()">+</button>
        <div class="status" id="status">Ready to create</div>
    </div>

    <div class="drop-zone" id="dropZone">
        Drop your text file here
    </div>

    <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvasInner">
            <div class="selection-rectangle" id="selectionRectangle"></div>
        </div>
    </div>

    <div class="color-picker" id="colorPicker">
        <div class="color-option" style="background: linear-gradient(145deg, #F2B5A0, #E8A08A)" data-color="coral" title="Coral"></div>
        <div class="color-option" style="background: linear-gradient(145deg, #E8DCCA, #D4C4A8)" data-color="sand" title="Sand"></div>
        <div class="color-option" style="background: linear-gradient(145deg, #F5D4CF, #E8B8B0)" data-color="pink" title="Pink"></div>
        <div class="color-option" style="background: linear-gradient(145deg, #B8C4D0, #9CAEBB)" data-color="slate" title="Slate"></div>
        <div class="color-option" style="background: linear-gradient(145deg, #D4C0A8, #C4A888)" data-color="tan" title="Tan"></div>
        <div class="color-option" style="background: linear-gradient(145deg, #8AA8A8, #6B8B8B)" data-color="teal" title="Teal"></div>
    </div>

    <script>
        let notes = [];
        let draggedNote = null;
        let didDrag = false;
        let dragOffset = { x: 0, y: 0 };
        let noteCounter = 0;
        let zoomLevel = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };

        let isGroupDragging = false;
        let groupDragStart = { x: 0, y: 0 };
        let groupDragOffsets = {};

        let isSelectMode = false;
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectedNotes = new Set();

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        document.addEventListener('dragover', handleDragOver);
        document.addEventListener('drop', handleFileDrop);
        document.addEventListener('dragleave', handleDragLeave);

        const canvas = document.getElementById('canvas');
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

        function focusOnNote(noteId) {
            const noteElement = document.getElementById(noteId);
            if (!noteElement) return;

            const canvas = document.getElementById('canvas');
            const noteRect = noteElement.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();

            // Calculate note position relative to canvas
            const noteX = parseInt(noteElement.style.left) * zoomLevel;
            const noteY = parseInt(noteElement.style.top) * zoomLevel;

            // Center the note in the viewport
            canvas.scrollLeft = noteX - canvas.clientWidth / 2;
            canvas.scrollTop = noteY - canvas.clientHeight / 2;
        }

        // Selection mode functions
        function toggleSelectMode() {
            isSelectMode = !isSelectMode;
            const btn = document.getElementById('selectNotesBtn');

            if (isSelectMode) {
                btn.classList.add('active');
                btn.textContent = 'Exit';
                canvas.style.cursor = 'crosshair';
                updateStatus('Selection mode â€” drag to select');
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Select';
                canvas.style.cursor = 'grab';
                clearSelection();
                updateStatus('Selection mode disabled');
            }
        }

        function clearSelection() {
            selectedNotes.forEach(noteId => {
                const note = document.getElementById(noteId);
                if (note) {
                    note.classList.remove('selected');
                }
            });
            selectedNotes.clear();
        }

        function handleCanvasMouseDown(e) {
            if (isSelectMode) {
                handleSelectionStart(e);
            } else {
                handlePanStart(e);
            }
        }

        function handleCanvasMouseMove(e) {
            if (isSelectMode && isSelecting) {
                handleSelectionMove(e);
            } else if (isPanning) {
                handlePanMove(e);
            }
        }

        function handleCanvasMouseUp(e) {
            if (isSelectMode && isSelecting) {
                handleSelectionEnd(e);
            } else {
                handlePanEnd(e);
            }
        }

        function handleCanvasMouseLeave(e) {
            if (isSelecting) {
                handleSelectionEnd(e);
            } else {
                handlePanEnd(e);
            }
        }

        function handleSelectionStart(e) {
            // Only start selection if clicking on canvas (not on a note)
            if (e.target.closest('.note')) return;

            isSelecting = true;
            const canvasRect = canvas.getBoundingClientRect();

            // Convert to canvas coordinates accounting for zoom and scroll
            selectionStart.x = (e.clientX - canvasRect.left + canvas.scrollLeft) / zoomLevel;
            selectionStart.y = (e.clientY - canvasRect.top + canvas.scrollTop) / zoomLevel;

            const selectionRect = document.getElementById('selectionRectangle');
            selectionRect.style.left = selectionStart.x + 'px';
            selectionRect.style.top = selectionStart.y + 'px';
            selectionRect.style.width = '0px';
            selectionRect.style.height = '0px';
            selectionRect.style.display = 'block';

            // Clear previous selection if not holding Ctrl/Cmd
            if (!e.ctrlKey && !e.metaKey) {
                clearSelection();
            }
        }

        function handleSelectionMove(e) {
            if (!isSelecting) return;

            const canvasRect = canvas.getBoundingClientRect();
            const currentX = (e.clientX - canvasRect.left + canvas.scrollLeft) / zoomLevel;
            const currentY = (e.clientY - canvasRect.top + canvas.scrollTop) / zoomLevel;

            const selectionRect = document.getElementById('selectionRectangle');
            const left = Math.min(selectionStart.x, currentX);
            const top = Math.min(selectionStart.y, currentY);
            const width = Math.abs(currentX - selectionStart.x);
            const height = Math.abs(currentY - selectionStart.y);

            selectionRect.style.left = left + 'px';
            selectionRect.style.top = top + 'px';
            selectionRect.style.width = width + 'px';
            selectionRect.style.height = height + 'px';

            // Update selection of notes
            updateNoteSelection(left, top, width, height);
        }

        function handleSelectionEnd(e) {
            if (!isSelecting) return;

            isSelecting = false;
            const selectionRect = document.getElementById('selectionRectangle');
            selectionRect.style.display = 'none';

            // Find all the PIDs within the selected notes, and log them
            let pids = new Set();
            selectedNotes.forEach(noteId => {
                const note = document.getElementById(noteId);
                // Extract out PID from the end of note text, e.g., (P8) -> P8
                const matches = noteText.match(/\(P(\d+)\)/g) ?? [];
                const pids = matches.map(m => Number(m.match(/\d+/)[0]));

            });
            pids = Array.from(pids).sort((a, b) => parseInt(a.replace("P", "")) - parseInt(b.replace("P", "")));

            updateStatus(`${selectedNotes.size} notes selected`);
        }

        function updateNoteSelection(left, top, width, height) {
            const selectionRight = left + width;
            const selectionBottom = top + height;

            // Check each note to see if it intersects with the selection rectangle
            const canvasInner = document.getElementById('canvasInner');
            const noteElements = canvasInner.querySelectorAll('.note');

            noteElements.forEach(note => {
                const noteLeft = parseInt(note.style.left);
                const noteTop = parseInt(note.style.top);
                const noteRight = noteLeft + note.offsetWidth;
                const noteBottom = noteTop + note.offsetHeight;

                // Check if note intersects with selection rectangle
                const intersects = !(noteRight < left ||
                                   noteLeft > selectionRight ||
                                   noteBottom < top ||
                                   noteTop > selectionBottom);

                if (intersects) {
                    if (!selectedNotes.has(note.id)) {
                        selectedNotes.add(note.id);
                        note.classList.add('selected');
                    }
                } else if (!isSelecting) {
                    // Only remove selection when we're done selecting (not during)
                    if (selectedNotes.has(note.id)) {
                        selectedNotes.delete(note.id);
                        note.classList.remove('selected');
                    }
                }
            });
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type === 'text/plain') {
                loadTextFile(file);
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.add('active');
        }

        function handleFileDrop(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'text/plain') {
                loadTextFile(files[0]);
            }
        }

        function handleDragLeave(e) {
            if (e.clientX === 0 && e.clientY === 0) {
                document.getElementById('dropZone').classList.remove('active');
            }
        }

        function loadTextFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const codes = text.split('\n').filter(line => line.trim() !== '');

                // Randomly shuffle codes
                // NOTE: This helps to kickstart affinity diagramming.
                codes.sort(() => Math.random() - 0.5);

                // Create notes from codes and add them to the board
                createNotesFromCodes(codes);
                updateStatus(`Loaded ${codes.length} codes`);
            };
            reader.readAsText(file);
        }

        function createNoteMenu(note) {
            const menu = document.createElement('div');
            menu.className = 'note-menu';

            const pinBtn = document.createElement('button');
            pinBtn.className = 'note-menu-btn pin-btn';
            pinBtn.title = 'Pin Note';
            pinBtn.innerHTML = 'ðŸ“Œ';
            pinBtn.onclick = () => {
                // Toggle pinned state
                if (note.classList.contains('pinned')) {
                    note.classList.remove('pinned');
                    updateStatus('Note unpinned');
                    // Update note data
                    const noteData = notes.find(n => n.id === note.id);
                    if (noteData) {
                        noteData.pinned = false;
                    }
                } else {
                    note.classList.add('pinned');
                    updateStatus('Note pinned');
                    // Update note data
                    const noteData = notes.find(n => n.id === note.id);
                    if (noteData) {
                        noteData.pinned = true;
                    }
                }
            };

            const colorBtn = document.createElement('button');
            colorBtn.className = 'note-menu-btn color-btn';
            colorBtn.title = 'Change Color';
            colorBtn.innerHTML = 'ðŸŽ¨';
            colorBtn.onclick = (e) => showColorPicker(e, note);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'note-menu-btn delete-btn';
            deleteBtn.innerHTML = 'Ã—';
            deleteBtn.title = 'Delete Note';
            deleteBtn.onclick = () => deleteNote(note);

            const duplicateBtn = document.createElement('button');
            duplicateBtn.className = 'note-menu-btn duplicate-btn';
            duplicateBtn.innerHTML = 'âŽ˜';
            duplicateBtn.title = 'Duplicate Note';
            duplicateBtn.onclick = () => {
                // Get note data
                const noteData = notes.find(n => n.id === note.id);
                const newNote = createNote(noteData.text, null, noteData.color, noteData.pinned);
                newNote.style.left = (noteData.x + 20) + 'px';
                newNote.style.top = (noteData.y + 20) + 'px';
                document.getElementById('canvasInner').appendChild(newNote);
                updateStatus('Note duplicated');
            };

            menu.appendChild(pinBtn);
            menu.appendChild(colorBtn);
            menu.appendChild(duplicateBtn);
            menu.appendChild(deleteBtn);
            return menu;
        }

        function createNotesFromCodes(codes) {
            const canvasInner = document.getElementById('canvasInner');

            codes.forEach((code, index) => {
                const note = createNote(code.trim(), index);
                canvasInner.appendChild(note);
            });
        }

        function createNote(text, index = null, color = 'yellow', pinned = false) {
            const note = document.createElement('div');
            note.className = `note color-${color}`;
            note.textContent = text;

            // Position notes in a grid initially
            if (index !== null) {
                // Random position within a predefined top-left area
                const x = Math.floor(Math.random() * 600) + 50;
                const y = Math.floor(Math.random() * 400) + 50;
                note.style.left = x + 'px';
                note.style.top = y + 'px';
            } else {
                note.style.left = '50px';
                note.style.top = '50px';
            }

            // Generate a UUID for the note
            const uuid = (crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${noteCounter++}`);
            note.id = `note-${uuid}`;


            // Create note menu
            const menu = createNoteMenu(note);
            note.appendChild(menu);

            // Create pin indicator
            const pinIndicator = document.createElement('div');
            pinIndicator.className = 'pin-indicator';
            note.appendChild(pinIndicator);
            if (pinned)
                note.classList.add('pinned');

            // Make draggable
            note.addEventListener('mousedown', startDrag);

            // Make editable
            makeNoteEditable(note);

            // Store note data
            notes.push({
                id: note.id,
                text: text,
                x: parseInt(note.style.left),
                y: parseInt(note.style.top),
                color: color,
                pinned: pinned,
            });

            return note;
        }

        function addNewNote() {
            const canvas = document.getElementById('canvas');
            const canvasInner = document.getElementById('canvasInner');

            // Calculate the center of the current visible area
            const viewportCenterX = (canvas.scrollLeft + canvas.clientWidth / 2) / zoomLevel;
            const viewportCenterY = (canvas.scrollTop + canvas.clientHeight / 2) / zoomLevel;

            // Create a new blank note
            const note = createNote('Double-click to edit');

            // Position it at the center of the viewport
            note.style.left = (viewportCenterX - 90) + 'px'; // 90 is half the note width (180px)
            note.style.top = (viewportCenterY - 60) + 'px';  // 60 is half the note height (120px)

            // Update the note data with the new position
            const noteData = notes.find(n => n.id === note.id);
            if (noteData) {
                noteData.x = parseInt(note.style.left);
                noteData.y = parseInt(note.style.top);
            }

            // Add the note to the canvas
            canvasInner.appendChild(note);

            // Make the note editable immediately
            makeNoteEditable(note);

            updateStatus('New note added');
        }

        function makeNoteEditable(note) {
            // Add double-click event to make notes editable
            note.addEventListener('dblclick', function(e) {
                // Don't edit if in select mode
                if (isSelectMode) return;

                e.stopPropagation();

                const nodeData = notes.find(n => n.id === note.id);
                const currentText = nodeData ? nodeData.text : note.textContent;
                const textarea = document.createElement('textarea');
                textarea.value = currentText;
                textarea.style.width = '100%';
                textarea.style.height = '100%';
                textarea.style.border = 'none';
                textarea.style.background = 'transparent';
                textarea.style.resize = 'none';
                textarea.style.font = 'inherit';
                textarea.style.padding = '0';
                textarea.style.margin = '0';
                textarea.style.outline = 'none';

                note.innerHTML = '';
                note.appendChild(textarea);
                textarea.focus();
                textarea.select();

                function finishEditing() {
                    const newText = textarea.value.trim() || 'Double-click to edit';
                    note.textContent = newText;

                    // Recreate the note menu
                    const menu = createNoteMenu(note);
                    note.appendChild(menu);

                    // Update note data
                    const noteData = notes.find(n => n.id === note.id);
                    if (noteData) {
                        noteData.text = newText;
                    }
                }

                textarea.addEventListener('blur', finishEditing);
                textarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        finishEditing();
                    }
                    if (e.key === 'Escape') {
                        finishEditing();
                    }
                });
            });
        }

        function startDrag(e) {
            // Don't start drag if we're clicking on menu buttons
            if (e.target.closest('.note-menu-btn')) return;
            // Don't start drag if we're panning
            if (isPanning) return;
            // Don't start drag if there's a textarea (editing)
            if (e.target.closest('textarea')) return;

            const noteElem = e.target.closest('.note');

            if (window.appState?.board) window.appState.board.setLastFocused(noteElem.id);

            if (isSelectMode && selectedNotes.has(noteElem.id)) {
                // Start group drag
                isGroupDragging = true;
                groupDragStart.x = e.clientX;
                groupDragStart.y = e.clientY;
                groupDragOffsets = {};
                selectedNotes.forEach(noteId => {
                    const n = document.getElementById(noteId);
                    groupDragOffsets[noteId] = {
                        x: parseInt(n.style.left),
                        y: parseInt(n.style.top)
                    };
                    n.classList.add('dragging');
                });
                document.addEventListener('mousemove', groupDragMove);
                document.addEventListener('mouseup', endGroupDrag);
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            if (isSelectMode) return; // Don't drag single notes in select mode unless part of group

            e.preventDefault();
            e.stopPropagation();
            draggedNote = noteElem;
            draggedNote.classList.add('dragging');
            const rect = draggedNote.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            didDrag = false;
        }

        function groupDragMove(e) {
            if (!isGroupDragging) return;
            const dx = (e.clientX - groupDragStart.x) / zoomLevel;
            const dy = (e.clientY - groupDragStart.y) / zoomLevel;
            selectedNotes.forEach(noteId => {
                const n = document.getElementById(noteId);
                const start = groupDragOffsets[noteId];
                n.style.left = Math.max(0, start.x + dx) + 'px';
                n.style.top = Math.max(0, start.y + dy) + 'px';
            });
        }

        function endGroupDrag() {
            if (!isGroupDragging) return;
            selectedNotes.forEach(noteId => {
                const n = document.getElementById(noteId);
                n.classList.remove('dragging');
                // Update note data
                const noteData = notes.find(nd => nd.id === noteId);
                if (noteData) {
                    noteData.x = parseInt(n.style.left);
                    noteData.y = parseInt(n.style.top);
                }
                // Move to end for z-order
                const p = n.parentNode;
                p.removeChild(n);
                p.appendChild(n);
            });
            isGroupDragging = false;
            groupDragOffsets = {};
            document.removeEventListener('mousemove', groupDragMove);
            document.removeEventListener('mouseup', endGroupDrag);
        }

        function drag(e) {
            if (!draggedNote) return;

            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();

            // Adjust for zoom level by dividing by zoomLevel
            const x = (e.clientX - canvasRect.left - dragOffset.x + canvas.scrollLeft) / zoomLevel;
            const y = (e.clientY - canvasRect.top - dragOffset.y + canvas.scrollTop) / zoomLevel;

            draggedNote.style.left = Math.max(0, x) + 'px';
            draggedNote.style.top = Math.max(0, y) + 'px';

            didDrag = true;
        }

        function endDrag() {
            if (draggedNote) {
                draggedNote.classList.remove('dragging');

                // Only remove and re-append if the note was actually moved
                if (didDrag) {
                    // Update note data, moving it to the end of the array to maintain render order
                    const noteIdx = notes.findIndex(n => n.id === draggedNote.id);
                    if (noteIdx !== -1) {
                        // Move note data to end of array to maintain z-order
                        const [noteData] = notes.splice(noteIdx, 1);
                        noteData.x = parseInt(draggedNote.style.left);
                        noteData.y = parseInt(draggedNote.style.top);
                        notes.push(noteData);
                    }

                    // Move the note to the end of the container to ensure it renders on top
                    const p = draggedNote.parentNode;
                    p.removeChild(draggedNote);
                    p.appendChild(draggedNote);

                    didDrag = false;
                }
                draggedNote = null;
            }

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
        }

        function showColorPicker(e, note) {
            e.stopPropagation();
            const colorPicker = document.getElementById('colorPicker');
            colorPicker.style.display = 'flex';
            colorPicker.style.left = e.pageX + 'px';
            colorPicker.style.top = e.pageY + 'px';

            colorPicker.onclick = (e) => {
                const color = e.target.dataset.color;
                if (color) {
                    changeNoteColor(note, color);
                    colorPicker.style.display = 'none';
                }
            };

            // Close color picker when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', function closeColorPicker() {
                    colorPicker.style.display = 'none';
                    document.removeEventListener('click', closeColorPicker);
                });
            }, 100);
        }

        function changeNoteColor(noteDiv, color) {
            // Remove existing color class
            noteDiv.classList.remove(...noteDiv.className.split(' ').filter(c => c.startsWith('color-')));
            // Add new color class
            noteDiv.classList.add(`color-${color}`);

            // Update note data
            const noteData = notes.find(n => n.id === noteDiv.id);
            if (noteData) {
                noteData.color = color;
            }
        }

        function deleteNote(note) {
            note.remove();
            notes = notes.filter(n => n.id !== note.id);
            updateStatus(`Note deleted. ${notes.length} remaining`);
        }

        function saveBoard() {
            const boardData = {
                notes: notes,
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(boardData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `splat-board-${new Date().toISOString().split('T')[0]}.json`;
            link.click();

            updateStatus('Board saved');
        }

        function loadBoard() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const boardData = JSON.parse(e.target.result);
                            restoreBoard(boardData);
                            updateStatus(`Board loaded with ${boardData.notes.length} notes`);
                        } catch (error) {
                            alert('Error loading board file');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function restoreBoard(boardData) {
            clearBoard();
            const canvasInner = document.getElementById('canvasInner');

            boardData.notes.forEach(noteData => {
                const note = createNoteFromData(noteData);
                canvasInner.appendChild(note);
            });

            notes = [...boardData.notes];
            noteCounter = notes.length;
            clearSelection();
        }

        function createNoteFromData(noteData) {
            const note = document.createElement('div');
            note.className = `note color-${noteData.color}`;
            note.textContent = noteData.text;
            note.id = noteData.id;
            note.style.left = noteData.x + 'px';
            note.style.top = noteData.y + 'px';

            // Apply pinned state if it exists
            if (noteData.pinned) {
                note.classList.add('pinned');
            }

            // Create note menu
            const menu = createNoteMenu(note);
            note.appendChild(menu);

            // Create pin indicator
            const pinIndicator = document.createElement('div');
            pinIndicator.className = 'pin-indicator';
            note.appendChild(pinIndicator);

            // Make draggable
            note.addEventListener('mousedown', startDrag);

            // Make editable
            makeNoteEditable(note);

            return note;
        }

        function clearBoard() {
            document.getElementById('canvasInner').innerHTML = '';
            // Re-add the selection rectangle
            const selectionRect = document.createElement('div');
            selectionRect.className = 'selection-rectangle';
            selectionRect.id = 'selectionRectangle';
            document.getElementById('canvasInner').appendChild(selectionRect);

            notes = [];
            noteCounter = 0;
            clearSelection();
            updateStatus('Board cleared');
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function handlePanStart(e) {
            // Only pan if clicking on canvas (not on a note) and not in select mode
            if (e.target.closest('.note') || isSelectMode) return;

            isPanning = true;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
            panOffset.x = canvas.scrollLeft;
            panOffset.y = canvas.scrollTop;
            canvas.style.cursor = 'grabbing';
        }

        function handlePanMove(e) {
            if (!isPanning) return;

            e.preventDefault();
            const deltaX = panStart.x - e.clientX;
            const deltaY = panStart.y - e.clientY;

            canvas.scrollLeft = panOffset.x + deltaX;
            canvas.scrollTop = panOffset.y + deltaY;
        }

        function handlePanEnd() {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
            }
        }

        function zoomIn() {
            const newZoom = Math.min(zoomLevel + 0.25, 3);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                applyZoom();
                updateZoomStatus();
            }
        }

        function zoomOut() {
            const newZoom = Math.max(zoomLevel - 0.25, 0.25);
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                applyZoom();
                updateZoomStatus();
            }
        }

        function resetZoom() {
            if (zoomLevel !== 1) {
                zoomLevel = 1;
                applyZoom();
                updateZoomStatus();
            }
        }

        function applyZoom() {
            const canvasInner = document.getElementById('canvasInner');
            canvasInner.style.transform = `scale(${zoomLevel})`;

            // Update background grid size to match zoom
            const gridSize = 24 * zoomLevel;
            canvas.style.backgroundSize = `${gridSize}px ${gridSize}px`;
        }

        function updateZoomStatus() {
            const zoomPercent = Math.round(zoomLevel * 100);
            const statusEl = document.getElementById('status');
            const currentText = statusEl.textContent;

            // Update zoom in status, but preserve other messages for a few seconds
            if (currentText.includes('%') || currentText === 'Ready to create') {
                statusEl.textContent = `Zoom: ${zoomPercent}%`;
            } else {
                statusEl.textContent = `${currentText} (${zoomPercent}%)`;
            }
        }

        // Prevent default drag behavior on the canvas
        document.getElementById('canvas').addEventListener('dragstart', e => e.preventDefault());
    </script>
    <script type="module">

        class BM25 {
            constructor() {
                this.k1 = 0.9;
                this.b = 0.4;
                this.documents = new Map();
                this.invertedIndex = new Map();
                this.termFreqs = new Map();
                this.docFreqs = new Map();
                this.totalDocs = 0;
                this.avgDocLength = 0;
                // Stopword list
                this.stopWords = new Set("a,about,above,after,again,against,all,am,an,and,any,are,aren't,as,at,be,because,been,before,being,below,between,both,but,by,can't,cannot,could,couldn't,did,didn't,do,does,doesn't,doing,don't,down,during,each,few,for,from,further,had,hadn't,has,hasn't,have,haven't,having,he,he'd,he'll,he's,her,here,here's,hers,herself,him,himself,his,how,how's,i,i'd,i'll,i'm,i've,if,in,into,is,isn't,it,it's,its,itself,let's,me,more,most,mustn't,my,myself,no,nor,not,of,off,on,once,only,or,other,ought,our,ours,ourselves,out,over,own,same,shan't,she,she'd,she'll,she's,should,shouldn't,so,some,such,than,that,that's,the,their,theirs,them,themselves,then,there,there's,these,they,they'd,they'll,they're,they've,this,those,through,to,too,under,until,up,very,was,wasn't,we,we'd,we'll,we're,we've,were,weren't,what,what's,when,when's,where,where's,which,while,who,who's,whom,why,why's,with,won't,would,wouldn't,you,you'd,you'll,you're,you've,your,yours,yourself,yourselves".split(","));
            }

            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s'-]/g, ' ')
                    .split(/\s+/)
                    .filter(t => t.length > 1 && !this.stopWords.has(t));
            }

            addDocument(id, text) {
                const tokens = this.tokenize(text);
                const length = tokens.length;

                const totalLength = this.avgDocLength * this.totalDocs + length;
                this.totalDocs++;
                this.avgDocLength = totalLength / this.totalDocs;

                this.documents.set(id, { text, tokens, length });

                const termCounts = new Map();
                for (const term of tokens) termCounts.set(term, (termCounts.get(term) || 0) + 1);

                for (const [term, count] of termCounts) {
                    if (!this.invertedIndex.has(term)) {
                        this.invertedIndex.set(term, new Set());
                        this.termFreqs.set(term, new Map());
                    }
                    this.invertedIndex.get(term).add(id);
                    this.termFreqs.get(term).set(id, count);
                    this.docFreqs.set(term, (this.docFreqs.get(term) || 0) + 1);
                }
            }

            removeDocument(id) {
                const doc = this.documents.get(id);
                if (!doc) return;

                const totalLength = this.avgDocLength * this.totalDocs - doc.length;
                this.totalDocs--;
                this.avgDocLength = this.totalDocs > 0 ? totalLength / this.totalDocs : 0;

                for (const term of new Set(doc.tokens)) {
                    this.invertedIndex.get(term)?.delete(id);
                    this.termFreqs.get(term)?.delete(id);
                    const newDocFreq = (this.docFreqs.get(term) || 1) - 1;
                    if (newDocFreq <= 0) {
                        this.invertedIndex.delete(term);
                        this.termFreqs.delete(term);
                        this.docFreqs.delete(term);
                    } else {
                        this.docFreqs.set(term, newDocFreq);
                    }
                }
                this.documents.delete(id);
            }

            idf(term) {
                return Math.log((this.totalDocs - (this.docFreqs.get(term) || 0) + 0.5) / ((this.docFreqs.get(term) || 0) + 0.5) + 1);
            }

            search(query, topK = 10) {
                const queryTokens = this.tokenize(query);
                if (queryTokens.length === 0) return [];

                const scores = new Map();
                for (const term of queryTokens) {
                    const docIds = this.invertedIndex.get(term);
                    if (!docIds) continue;

                    const idf = this.idf(term);
                    for (const docId of docIds) {
                        const doc = this.documents.get(docId);
                        const tf = this.termFreqs.get(term).get(docId);
                        const lengthNorm = 1 - this.b + this.b * (doc.length / this.avgDocLength);
                        const score = idf * ((tf * (this.k1 + 1)) / (tf + this.k1 * lengthNorm));
                        scores.set(docId, (scores.get(docId) || 0) + score);
                    }
                }

                return Array.from(scores.entries())
                    .map(([docId, score]) => ({ docId, score }))
                    .sort((a, b) => b.score - a.score)
                    .slice(0, topK);
            }
        }

        class VectorSearch {
            constructor() {
                this.embeddings = new Map();
                this.extractor = null;
                this.isReady = false;
            }

            async init() {
                if (this.isReady) return;

                try {
                    const modelName = 'Xenova/all-MiniLM-L6-v2';
                    const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3');

                    env.backends.onnx.wasm.proxy = true;
                    this.extractor = await pipeline('feature-extraction', modelName, {
                        dtype: 'q8',
                        device: 'webgpu'
                    });
                    this.isReady = true;
                } catch (err) {
                    console.error('VectorSearch init failed (using keyword fallback):', err);
                    this.isReady = false;
                }
            }

            async embed(text) {
                if (!this.isReady) await this.init();
                const output = await this.extractor(text, { pooling: 'mean', normalize: true });
                return new Float32Array(output.data);
            }

            async indexNote(id, text) {
                if (!this.isReady) return;
                const embedding = await this.embed(text);
                this.embeddings.set(id, embedding);
            }

            cosineSimilarity(a, b) {
                let dot = 0;
                for (let i = 0; i < a.length; i++) dot += a[i] * b[i];
                return dot;
            }

            async search(query, topK = 10) {
                if (!this.isReady) return [];
                const queryEmbedding = await this.embed(query);
                const results = [];
                for (const [id, embedding] of this.embeddings) {
                    results.push({ docId: id, score: this.cosineSimilarity(queryEmbedding, embedding) });
                }
                return results.sort((a, b) => b.score - a.score).slice(0, topK);
            }

            removeNote(id) {
                this.embeddings.delete(id);
            }
        }

        class HybridSearch {
            constructor() {
                this.notes = [];
                this.bm25 = new BM25();
                this.vectorSearch = new VectorSearch();
            }

            async initialize() {
                await this.vectorSearch.init();
            }

            async addNote(id, text) {
                this.removeNote(id, false);
                this.notes.push({ id, text });
                this.bm25.addDocument(id, text);
                this.vectorSearch.indexNote(id, text).catch(e => console.warn("Vector indexing error", e));
            }

            async addNotesBatch(notes) {
                for (const note of notes) {
                    this.notes.push(note);
                    this.bm25.addDocument(note.id, note.text);
                }
                for (const note of notes) {
                    await this.vectorSearch.indexNote(note.id, note.text);
                }
            }

            removeNote(id, removeFromList = true) {
                if (removeFromList) this.notes = this.notes.filter(n => n.id !== id);
                this.bm25.removeDocument(id);
                this.vectorSearch.removeNote(id);
            }

            keywordSearch(keyword) {
                const kw = keyword.toLowerCase();
                return this.notes
                    .filter(n => n.text.toLowerCase().includes(kw))
                    .map(n => ({ id: n.id, text: n.text }));
            }

            // Reciprocal Rank Fusion
            rrfScore(bm25Rank, vectorRank) {
                const k = 60;
                const bm25Weight = 0.4;
                const vectorWeight = 0.6;
                return (bm25Weight / (k + bm25Rank)) + (vectorWeight / (k + vectorRank));
            }

            async search(query, options = {}) {
                const topK = options.topK || 10;
                const retrievalK = 50;

                const [bm25Results, vectorResults] = await Promise.all([
                    Promise.resolve(this.bm25.search(query, retrievalK)),
                    this.vectorSearch.search(query, retrievalK)
                ]);

                const allIds = new Set([...bm25Results.map(r => r.docId), ...vectorResults.map(r => r.docId)]);
                const bm25Map = new Map(bm25Results.map((r, i) => [r.docId, i + 1]));
                const vectorMap = new Map(vectorResults.map((r, i) => [r.docId, i + 1]));

                const fused = [];
                for (const id of allIds) {
                    const r1 = bm25Map.get(id) || (retrievalK + 1);
                    const r2 = vectorMap.get(id) || (retrievalK + 1);
                    fused.push({ id, score: this.rrfScore(r1, r2) });
                }

                return {
                    results: fused.sort((a, b) => b.score - a.score).slice(0, topK)
                };
            }
        }

        class BoardState {
            constructor() {
                this.lastFocusedNoteId = null;
            }

            setLastFocused(noteId) { this.lastFocusedNoteId = noteId; }
            getLastFocusedNoteId() { return this.lastFocusedNoteId; }

            getNote(id) { return notes.find(n => n.id === id); }
            getNoteText(id) { return this.getNote(id)?.text || null; }
            getNoteColor(id) { return this.getNote(id)?.color || null; }
            getSelectedNoteIds() { return Array.from(selectedNotes); }
            getNotesByColor(color) { return notes.filter(n => n.color === color); }

            getAllNotes() {
                return notes.map(n => ({ id: n.id, text: n.text, color: n.color, x: n.x, y: n.y }));
            }

            highlightNotes(ids, type = 'search') {
                document.querySelectorAll('.note').forEach(el =>
                    el.classList.remove('search-highlight', 'ai-highlight', 'warning-highlight')
                );

                if (!ids || ids.length === 0) return;

                const className = {
                    'search': 'search-highlight',
                    'ai': 'ai-highlight',
                    'warning': 'warning-highlight'
                }[type] || 'search-highlight';

                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.add(className);
                        el.parentNode.appendChild(el);
                    }
                });

                if (ids.length > 0) focusOnNote(ids[0]);
            }

            async createNote(text, color = 'yellow', pos = {x: 100, y: 100}) {
                const note = createNote(text, null, color, false); // Default to not pinned
                note.style.left = pos.x + 'px';
                note.style.top = pos.y + 'px';
                const data = notes.find(n => n.id === note.id);
                if (data) { data.x = pos.x; data.y = pos.y; }
                document.getElementById('canvasInner').appendChild(note);
                return note.id;
            }

            deleteNote(id) {
                const el = document.getElementById(id);
                if (el) {
                    el.remove();
                    const idx = notes.findIndex(n => n.id === id);
                    if (idx > -1) notes.splice(idx, 1);
                }
            }

            setNoteColor(id, color) {
                const el = document.getElementById(id);
                const data = this.getNote(id);
                if (el && data) {
                    el.classList.remove(...Array.from(el.classList).filter(c => c.startsWith('color-')));
                    el.classList.add(`color-${color}`);
                    data.color = color;
                }
            }
        }

        const TOOL_DEFINITIONS = [
            {
                name: "semantic_search",
                description: "Search notes using hybrid retrieval. Use for meaning/topic searches.",
                input_schema: {
                    type: "object",
                    properties: { query: { type: "string" }, top_k: { type: "integer" } },
                    required: ["query"]
                }
            },
            {
                name: "keyword_search",
                description: "Find notes containing an EXACT keyword phrase.",
                input_schema: {
                    type: "object",
                    properties: { keyword: { type: "string" } },
                    required: ["keyword"]
                }
            },
            {
                name: "get_notes",
                description: "Get content of specific notes by ID.",
                input_schema: {
                    type: "object",
                    properties: { ids: { type: "array", items: { type: "string" } } },
                    required: ["ids"]
                }
            },
            {
                name: "get_selected",
                description: "Get notes currently selected by user.",
                input_schema: { type: "object", properties: {} }
            },
            {
                name: "get_last_focused",
                description: "Get the note most recently touched/edited.",
                input_schema: { type: "object", properties: {} }
            },
            {
                name: "get_all_notes_of_color",
                description: "Get all notes of a specific color.",
                input_schema: {
                    type: "object",
                    properties: {
                        color: { type: "string", enum: ["coral", "sand", "pink", "slate", "tan", "teal"] }
                    },
                    required: ["color"]
                }
            },
            {
                name: "add_notes",
                description: "Add new notes to the board.",
                input_schema: {
                    type: "object",
                    properties: {
                        notes: {
                            type: "array",
                            items: {
                                type: "object",
                                properties: { text: { type: "string" }, color: { type: "string" } },
                                required: ["text"]
                            }
                        },
                        near_note_id: { type: "string" }
                    },
                    required: ["notes"]
                }
            },
            {
                name: "edit_note",
                description: "Edit content of an existing note.",
                input_schema: {
                    type: "object",
                    properties: { id: { type: "string" }, new_content: { type: "string" } },
                    required: ["id", "new_content"]
                }
            },
            {
                name: "remove_notes",
                description: "Remove notes (highlights and asks confirmation first).",
                input_schema: {
                    type: "object",
                    properties: { ids: { type: "array", items: { type: "string" } } },
                    required: ["ids"]
                }
            },
            {
                name: "set_note_color",
                description: "Change color of notes.",
                input_schema: {
                    type: "object",
                    properties: {
                        ids: { type: "array", items: { type: "string" } },
                        color: { type: "string" }
                    },
                    required: ["ids", "color"]
                }
            },
            {
                name: "highlight_notes",
                description: "Visually highlight notes.",
                input_schema: {
                    type: "object",
                    properties: { ids: { type: "array", items: { type: "string" } } },
                    required: ["ids"]
                }
            }
        ];

        class ToolExecutor {
            constructor(boardState, hybridSearch) {
                this.board = boardState;
                this.search = hybridSearch;
            }

            async execute(name, args) {
                console.log(`[Tool] ${name}`, args);
                switch (name) {
                    case 'semantic_search': {
                        const { results } = await this.search.search(args.query, { topK: args.top_k || 10 });
                        const ids = results.map(r => r.id);
                        this.board.highlightNotes(ids, 'search');
                        return results.map(r => ({
                            id: r.id,
                            text: this.board.getNoteText(r.id),
                            score: r.score.toFixed(3)
                        }));
                    }
                    case 'keyword_search': {
                        const results = this.search.keywordSearch(args.keyword);
                        this.board.highlightNotes(results.map(r => r.id), 'search');
                        return results;
                    }
                    case 'get_notes':
                        return args.ids.map(id => ({ id, text: this.board.getNoteText(id), color: this.board.getNoteColor(id) }));
                    case 'get_selected':
                        return this.board.getSelectedNoteIds().map(id => ({ id, text: this.board.getNoteText(id).length > 200 ? this.board.getNoteText(id).substring(0, 200) + "..." : this.board.getNoteText(id) }));
                    case 'get_last_focused': {
                        const id = this.board.getLastFocusedNoteId();
                        return id ? { id, text: this.board.getNoteText(id) } : { error: "No recent note" };
                    }
                    case 'get_all_notes_of_color':
                        return this.board.getNotesByColor(args.color).map(n => ({ id: n.id, text: n.text }));
                    case 'add_notes': {
                        const created = [];
                        let baseX = 100, baseY = 100;
                        if (args.near_note_id) {
                            const pos = this.board.getNote(args.near_note_id);
                            if (pos) { baseX = pos.x + 40; baseY = pos.y + 40; }
                        }
                        for (let i = 0; i < args.notes.length; i++) {
                            const n = args.notes[i];
                            const id = await this.board.createNote(n.text, n.color || 'yellow', {
                                x: baseX + (i % 3) * 230,
                                y: baseY + Math.floor(i / 3) * 140
                            });
                            await this.search.addNote(id, n.text);
                            created.push(id);
                        }
                        this.board.highlightNotes(created, 'ai');
                        return { created_ids: created };
                    }
                    case 'edit_note': {
                        const note = this.board.getNote(args.id);
                        if (note) {
                            const noteElement = document.getElementById(args.id);
                            if (!noteElement) return { error: "Note not found" };

                            const textarea = document.createElement('textarea');
                            textarea.value = args.new_content;
                            textarea.style.width = '100%';
                            textarea.style.height = '100%';
                            textarea.style.border = 'none';
                            textarea.style.background = 'transparent';
                            textarea.style.resize = 'none';
                            textarea.style.font = 'inherit';
                            textarea.style.padding = '0';
                            textarea.style.margin = '0';
                            textarea.style.outline = 'none';
                            textarea.style.overflowY = 'auto'; // Ensure scrollable if content is long

                            noteElement.innerHTML = '';
                            noteElement.appendChild(textarea);
                            textarea.focus();
                            textarea.select();

                            const finishEditing = () => {
                                const newText = textarea.value.trim();
                                noteElement.textContent = newText;
                                const menu = createNoteMenu(noteElement);
                                noteElement.appendChild(menu);

                                const noteData = notes.find(n => n.id === noteElement.id);
                                if (noteData) { noteData.text = newText; }
                                this.search.addNote(args.id, newText);
                            };

                            textarea.addEventListener('blur', finishEditing);
                            textarea.addEventListener('keydown', function(e) {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    finishEditing();
                                }
                                if (e.key === 'Escape') {
                                    finishEditing();
                                }
                            });
                            return { success: true };
                        }
                        return { error: "Note not found" };
                    }
                    case 'remove_notes': {
                        this.board.highlightNotes(args.ids, 'warning');
                        const confirm = await new Promise(r => setTimeout(() => r(window.confirm(`Delete ${args.ids.length} notes?`)), 100));
                        if (confirm) {
                            args.ids.forEach(id => {
                                this.board.deleteNote(id);
                                this.search.removeNote(id);
                            });
                            return { removed: args.ids.length };
                        }
                        return { cancelled: true };
                    }
                    case 'set_note_color':
                        args.ids.forEach(id => this.board.setNoteColor(id, args.color));
                        return { success: true };
                    case 'highlight_notes':
                        this.board.highlightNotes(args.ids, 'ai');
                        return { success: true };
                    default: return { error: "Unknown tool" };
                }
            }
        }

        class ChatAgent {
            constructor(toolExecutor) {
                this.executor = toolExecutor;
                this.history = [];
                this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('splat_ai_settings');
                    if (saved) {
                        const config = JSON.parse(saved);
                        this.provider = config.provider || 'ollama';
                        this.apiKey = config.apiKey || '';
                        this.ollamaUrl = config.ollamaUrl || 'http://localhost:11434';
                        this.model = config.model || '';
                    } else {
                        this.setDefaults();
                    }
                } catch (e) {
                    console.error("Failed to load settings", e);
                    this.setDefaults();
                }
            }

            setDefaults() {
                this.provider = 'ollama';
                this.apiKey = '';
                this.ollamaUrl = 'http://localhost:11434';
                this.model = '';
            }

            setProvider(provider, key, url, model) {
                this.provider = provider;
                this.apiKey = key;
                this.ollamaUrl = url || 'http://localhost:11434';
                this.model = model;

                localStorage.setItem('splat_ai_settings', JSON.stringify({
                    provider: this.provider,
                    apiKey: this.apiKey,
                    ollamaUrl: this.ollamaUrl,
                    model: this.model
                }));
            }

            async chat(message) {
                this.history.push({ role: 'user', content: message });

                let iterations = 0;
                const MAX_ITERATIONS = 8;

                while (iterations < MAX_ITERATIONS) {
                    iterations++;
                    try {
                        const response = await this.callLLM();

                        if (response.toolCalls) {
                            const results = [];
                            for (const call of response.toolCalls) {
                                try {
                                    const result = await this.executor.execute(call.name, call.input);
                                    results.push({ tool_use_id: call.id, content: JSON.stringify(result) });
                                } catch (e) {
                                    results.push({ tool_use_id: call.id, content: JSON.stringify({ error: e.message }), is_error: true });
                                }
                            }

                            this.history.push({ role: 'assistant', content: response.toolCallsRaw || null, tool_calls: response.toolCalls });
                            this.history.push({ role: 'user', content: results, is_tool_result: true });
                        } else {
                            this.history.push({ role: 'assistant', content: response.text });
                            return response.text;
                        }
                    } catch (err) {
                        console.error("LLM Error:", err);
                        return `Error connecting to AI (${this.provider}): ${err.message}. Check Settings.`;
                    }
                }
                return "Tool usage limit reached.";
            }

            async callLLM() {
                switch(this.provider) {
                    case 'anthropic': return this.callAnthropic();
                    case 'openai': return this.callOpenAI();
                    default: return this.callOllama();
                }
            }

            async callOllama() {
                const tools = TOOL_DEFINITIONS.map(t => ({ type: 'function', function: { name: t.name, description: t.description, parameters: t.input_schema } }));

                const messages = [{ role: 'system', content: "You are an AI assistant for Splat. Manage notes on a canvas. Use tools to search, select, edit, and color notes. Always use 'semantic_search' for topic queries" }];
                this.history.forEach(h => {
                    if (h.is_tool_result) {
                        h.content.forEach(r => messages.push({ role: 'tool', content: r.content }));
                    } else if (h.tool_calls) {
                        messages.push({ role: 'assistant', tool_calls: h.tool_calls.map(tc => ({ function: { name: tc.name, arguments: tc.input } })) });
                    } else {
                        messages.push({ role: h.role, content: h.content });
                    }
                });

                const modelToUse = this.model || 'llama3.1';

                const req = await fetch(`${this.ollamaUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: modelToUse, messages, tools, stream: false })
                });

                if (!req.ok) throw new Error("Ollama connection failed");
                const data = await req.json();
                const msg = data.message;

                if (msg.tool_calls) {
                    return {
                        text: "",
                        toolCalls: msg.tool_calls.map((tc, i) => ({ id: `call_${Date.now()}_${i}`, name: tc.function.name, input: tc.function.arguments }))
                    };
                }
                return { text: msg.content, toolCalls: null };
            }

            async callAnthropic() {
                const system = "You are an AI assistant for Splat. Manage notes on a canvas. Use tools to search, select, edit, and color notes. Always use 'semantic_search' for topic queries.";

                const messages = this.history.map(msg => {
                    if (msg.is_tool_result) {
                        return {
                            role: 'user',
                            content: msg.content.map(r => ({ type: 'tool_result', tool_use_id: r.tool_use_id, content: r.content, is_error: r.is_error }))
                        };
                    }
                    if (msg.tool_calls) {
                        return {
                            role: 'assistant',
                            content: msg.tool_calls.map(tc => ({ type: 'tool_use', id: tc.id, name: tc.name, input: tc.input }))
                        };
                    }
                    return { role: msg.role, content: msg.content };
                });

                const modelToUse = this.model || 'claude-3-5-sonnet-20240620';

                const req = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-api-key': this.apiKey, 'anthropic-version': '2023-06-01' },
                    body: JSON.stringify({ model: modelToUse, max_tokens: 1024, system, tools: TOOL_DEFINITIONS, messages })
                });

                if (!req.ok) throw new Error("Anthropic API Error");
                const data = await req.json();

                const textContent = data.content.filter(c => c.type === 'text').map(c => c.text).join('');
                const tools = data.content.filter(c => c.type === 'tool_use').map(c => ({ id: c.id, name: c.name, input: c.input }));

                return { text: textContent, toolCalls: tools.length ? tools : null };
            }

            async callOpenAI() {
                const tools = TOOL_DEFINITIONS.map(t => ({ type: 'function', function: { name: t.name, description: t.description, parameters: t.input_schema } }));

                const messages = [{ role: 'system', content: "You are an AI assistant for Splat. Manage notes on a canvas. Use tools to search, select, edit, and color notes. Always use 'semantic_search' for topic queries" }];
                this.history.forEach(h => {
                    if (h.is_tool_result) {
                        h.content.forEach(r => {
                            messages.push({ role: 'tool', tool_call_id: r.tool_use_id, content: r.content });
                        });
                    } else if (h.tool_calls) {
                        messages.push({ role: 'assistant', tool_calls: h.tool_calls.map(tc => ({ id: tc.id, type: 'function', function: { name: tc.name, arguments: JSON.stringify(tc.input) } })) });
                    } else {
                        messages.push({ role: h.role, content: h.content });
                    }
                });

                const modelToUse = this.model || 'gpt-4o';

                const req = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.apiKey}` },
                    body: JSON.stringify({ model: modelToUse, messages, tools })
                });

                if (!req.ok) throw new Error("OpenAI API Error");
                const data = await req.json();
                const choice = data.choices[0].message;

                if (choice.tool_calls) {
                    return {
                        text: null,
                        toolCalls: choice.tool_calls.map(tc => ({ id: tc.id, name: tc.function.name, input: JSON.parse(tc.function.arguments) }))
                    };
                }
                return { text: choice.content, toolCalls: null };
            }
        }

        class ChatUI {
            constructor(agent) {
                this.agent = agent;
                this.render();
                this.bindEvents();
            }

            render() {
                const pane = document.createElement('div');
                pane.className = 'chat-pane';
                pane.id = 'chatPane';
                pane.innerHTML = `
                    <div class="chat-header">
                        <span class="chat-title">Splat AI</span>
                        <div style="display:flex; gap:10px;">
                            <button id="settingsBtn" style="background:rgba(255,255,255,0.2); border:none; color:white; cursor:pointer; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-family: 'DM Sans', sans-serif;">Settings</button>
                            <button class="chat-close-btn" id="chatClose">x</button>
                        </div>
                    </div>
                    <div class="chat-messages" id="chatList">
                        <div class="chat-welcome">
                            <strong>Welcome to Splat AI</strong>
                            <p style="margin-top: 8px; color: var(--her-text-muted);">I can help you organize your notes. Try:</p>
                            <ul>
                                <li>"Find notes about..."</li>
                                <li>"Summarize the selected notes"</li>
                                <li>"Change blue notes to pink"</li>
                            </ul>
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <textarea id="chatIn" placeholder="Ask me anything..." rows="1"></textarea>
                        <button class="voice-input-btn" id="voiceBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                <line x1="12" x2="12" y1="19" y2="22"></line>
                            </svg>
                        </button>
                        <button class="chat-send-btn" id="sendBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="5" x2="19" y1="12" y2="12"></line>
                                <polyline points="12 5 19 12 12 19"></polyline>
                            </svg>
                        </button>
                    </div>
                    <div id="settingsPanel" style="display:none; position:absolute; top:60px; left:0; right:0; background:var(--her-cream); padding:20px; border-bottom:1px solid var(--her-sand); z-index:20; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">

                        <div id="setting-provider" style="margin-bottom: 16px;">
                            <label style="display:block; font-weight:500;">Provider:
                                <select id="provSel" style="width:100%; margin-top: 6px;">
                                    <option value="ollama">Ollama (Local)</option>
                                    <option value="openai">OpenAI</option>
                                    <option value="anthropic">Anthropic</option>
                                </select>
                            </label>
                        </div>

                        <div id="setting-apiKey" style="margin-bottom: 16px;">
                            <label style="display:block; font-weight:500;">API Key:
                                <input type="password" id="apiKeyIn" placeholder="sk-..." style="width:100%; margin-top: 6px;">
                            </label>
                        </div>

                        <div id="setting-model" style="margin-bottom: 16px;">
                            <label style="display:block; font-weight:500;">Model:
                                <input type="text" id="modelIn" placeholder="e.g. gpt-4o, claude-3-5..." style="width:100%; margin-top: 6px;">
                            </label>
                            <div style="font-size:11px; color:var(--her-slate); margin-top:4px;">Leave empty for default</div>
                        </div>

                        <div id="setting-url" style="margin-bottom: 16px;">
                            <label style="display:block; font-weight:500;">Ollama URL:
                                <input type="text" id="urlIn" value="http://localhost:11434" style="width:100%; margin-top: 6px;">
                            </label>
                        </div>

                        <button id="saveSettings" class="btn btn-primary" style="width: 100%;">Save Settings</button>
                    </div>`;
                document.body.appendChild(pane);

                const btn = document.createElement('button');
                btn.className = 'ask-button';
                btn.id = 'askButton';
                btn.title = 'Ask AI';
                btn.onclick = () => pane.classList.add('open');
                document.body.appendChild(btn);

                const tb = document.querySelector('.toolbar');
                const searchContainer = document.createElement('div');
                searchContainer.className = 'search-container';
                searchContainer.innerHTML = `
                    <input type="text" class="search-input" id="globalSearch" placeholder="Search notes...">
                    <button class="search-btn" id="globalSearchBtn">Search</button>
                `;
                tb.appendChild(searchContainer);
            }

            bindEvents() {
                document.getElementById('chatClose').onclick = () => document.getElementById('chatPane').classList.remove('open');

                // Settings Logic
                const setPanel = document.getElementById('settingsPanel');
                const provSel = document.getElementById('provSel');
                const apiKeyDiv = document.getElementById('setting-apiKey');
                const urlDiv = document.getElementById('setting-url');

                // Toggle field visibility based on provider
                const updateSettingsUI = () => {
                    const provider = provSel.value;
                    if (provider === 'ollama') {
                        apiKeyDiv.style.display = 'none';
                        urlDiv.style.display = 'block';
                    } else {
                        apiKeyDiv.style.display = 'block';
                        urlDiv.style.display = 'none';
                    }
                };

                // Listen for changes
                provSel.onchange = updateSettingsUI;

                document.getElementById('settingsBtn').onclick = () => {
                    if (setPanel.style.display === 'none') {
                        // Populate fields
                        provSel.value = this.agent.provider;
                        document.getElementById('apiKeyIn').value = this.agent.apiKey;
                        document.getElementById('urlIn').value = this.agent.ollamaUrl;
                        document.getElementById('modelIn').value = this.agent.model;

                        // Run logic to set correct visibility
                        updateSettingsUI();

                        setPanel.style.display = 'block';
                    } else {
                        setPanel.style.display = 'none';
                    }
                };

                document.getElementById('saveSettings').onclick = () => {
                    const prov = provSel.value;
                    const key = document.getElementById('apiKeyIn').value;
                    const url = document.getElementById('urlIn').value;
                    const mod = document.getElementById('modelIn').value;

                    this.agent.setProvider(prov, key, url, mod);

                    setPanel.style.display = 'none';

                    const btn = document.getElementById('saveSettings');
                    const origText = btn.textContent;
                    btn.textContent = 'Saved!';
                    setTimeout(() => btn.textContent = origText, 1000);
                };

                const send = async () => {
                    const inp = document.getElementById('chatIn');
                    const txt = inp.value.trim();
                    if (!txt) return;

                    const sendBtn = document.getElementById('sendBtn');
                    sendBtn.classList.add('loading');
                    sendBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="spinner-icon"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>`;

                    this.addMsg('user', txt);
                    inp.value = '';

                    const loadingId = this.addMsg('assistant', '<div class="loading-dots"><span></span><span></span><span></span></div>');

                    const response = await this.agent.chat(txt);

                    document.getElementById(loadingId).remove();
                    this.addMsg('assistant', response);

                    sendBtn.classList.remove('loading');
                    sendBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" x2="19" y1="12" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>`;
                };

                document.getElementById('sendBtn').onclick = send;
                document.getElementById('chatIn').onkeydown = (e) => { if(e.key==='Enter' && !e.shiftKey) { e.preventDefault(); send(); }};

                const runSearch = async () => {
                    const q = document.getElementById('globalSearch').value;
                    if (!q) return;

                    const searchBtn = document.getElementById('globalSearchBtn');
                    const originalContent = searchBtn.innerHTML;

                    searchBtn.classList.add('loading');
                    searchBtn.innerHTML = `<span class="search-spinner"></span><span>Searching</span>`;

                    try {
                        const toolEx = this.agent.executor;
                        await toolEx.execute('semantic_search', { query: q, top_k: 10 });
                    } finally {
                        searchBtn.classList.remove('loading');
                        searchBtn.innerHTML = originalContent;
                    }
                };
                document.getElementById('globalSearchBtn').onclick = runSearch;
                document.getElementById('globalSearch').onkeydown = (e) => { if(e.key==='Enter') runSearch(); };
            }

            addMsg(role, text) {
                const div = document.createElement('div');
                div.className = `chat-message chat-message-${role}`;
                div.id = `msg-${Date.now()}`;
                div.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>').replace(/\n/g, '<br>');
                const list = document.getElementById('chatList');
                list.appendChild(div);
                list.scrollTop = list.scrollHeight;
                return div.id;
            }
        }

        class VoiceIntegration {
            constructor(chatUI) {
                this.chatUI = chatUI;
                this.isRecording = false;
                this.mediaRecorder = null;
                this.chunks = [];
                this.transcriberPromise = null;
                this.stream = null;

                this.icons = {
                    mic: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" x2="12" y1="19" y2="22"></line>
                    </svg>`,
                    stop: `<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <rect x="6" y="6" width="12" height="12" rx="2"></rect>
                    </svg>`,
                    processing: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="spinner-icon">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
                    </svg>`
                };

                const btn = document.getElementById('voiceBtn');
                btn.onclick = () => this.toggle();
            }

            setButtonIcon(iconName) {
                const btn = document.getElementById('voiceBtn');
                btn.innerHTML = this.icons[iconName];
            }

            async getTranscriber() {
                if (!this.transcriberPromise) {
                    this.transcriberPromise = (async () => {
                    const { pipeline, env, read_audio } =
                        await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3');

                    env.backends.onnx.wasm.proxy = true;

                    // cache read_audio for later use in process()
                    this.read_audio = read_audio;

                    return pipeline(
                        'automatic-speech-recognition',
                        'onnx-community/moonshine-tiny-ONNX',
                        { dtype: 'fp32', device: 'wasm' }
                    );
                    })();
                }
                return this.transcriberPromise;
                }


            async toggle() {
                if (this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    document.getElementById('voiceBtn').classList.remove('recording');
                    this.setButtonIcon('mic');
                } else {
                    try {
                        this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const mimeType = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4',
                        ].find(t => MediaRecorder.isTypeSupported(t));

                        this.mediaRecorder = new MediaRecorder(
                        this.stream,
                        mimeType ? { mimeType } : undefined
                        );
                        this.chunks = [];
                        this.mediaRecorder.ondataavailable = e => this.chunks.push(e.data);
                        this.mediaRecorder.onstop = () => {
                            this.stream?.getTracks().forEach(t => t.stop());
                            this.stream = null;
                            this.process();
                        };
                        this.mediaRecorder.start();
                        this.isRecording = true;
                        document.getElementById('voiceBtn').classList.add('recording');
                        this.setButtonIcon('stop');
                    } catch (e) {
                        alert("Mic access denied");
                    }
                }
            }

            async process() {
                const blob = new Blob(this.chunks, { type: this.mediaRecorder?.mimeType || 'audio/webm' });

                const btn = document.getElementById('voiceBtn');
                btn.classList.add('transcribing');
                this.setButtonIcon('processing');

                const url = URL.createObjectURL(blob);

                try {
                    const transcriber = await this.getTranscriber();

                    const audio = await this.read_audio(url, 16000);

                    const output = await transcriber(audio);

                    const text = (typeof output === "string") ? output : (output?.text ?? "");
                    const inp = document.getElementById('chatIn');
                    inp.value = (inp.value + " " + text).trim();
                } catch (e) {
                    console.error(e);
                    alert("Transcription failed.");
                } finally {
                    URL.revokeObjectURL(url);
                    btn.classList.remove('transcribing');
                    this.setButtonIcon('mic');
                    this.chunks = [];
                }
                }

        }

        let appState = {
            search: new HybridSearch(),
            board: new BoardState(),
            agent: null
        };

        window.appState = appState;

        window.createNoteHook = async (id, text) => {
            if (appState.search) await appState.search.addNote(id, text);
        };

        const originalCreateNote = window.createNote;
        window.createNote = function(text, index, color, pinned) {
            const note = originalCreateNote(text, index, color, pinned);
            window.createNoteHook(note.id, text);
            return note;
        };

        const originalDeleteNote = window.deleteNote;
        window.deleteNote = function(note) {
            const id = note.id;
            originalDeleteNote(note);
            if (appState.search) appState.search.removeNote(id);
        };

        const originalMakeNoteEditable = window.makeNoteEditable;
        window.makeNoteEditable = function(note) {
            originalMakeNoteEditable(note);
            note.addEventListener('dblclick', () => {
                const ta = note.querySelector('textarea');
                if(ta) {
                    appState.board.setLastFocused(note.id);
                    ta.addEventListener('blur', () => {
                        setTimeout(() => {
                            const newText = note.textContent;
                            appState.search.addNote(note.id, newText);
                        }, 100);
                    });
                }
            });
        };

        async function init() {
            console.log("Initializing Splat AI...");
            await appState.search.initialize();

            if (window.notes && window.notes.length) {
                await appState.search.addNotesBatch(window.notes);
            }

            const tools = new ToolExecutor(appState.board, appState.search);
            appState.agent = new ChatAgent(tools);

            const ui = new ChatUI(appState.agent);
            new VoiceIntegration(ui);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>
